#!/usr/bin/env python3

import os
from lib.types import Module, Endpoint
from lib.utils import type2typescript
from texts import texts as TEMPL

# ==================================================================================================
# INTERNAL FUNCTIONS
# ==================================================================================================

# ==================================================================================================
# CLASS METHODS
# ==================================================================================================
def generate_file_reducer_functions ( self, mod: Module, output: str ):
	mod_name = self.mod_name( mod )

	# create the output directory
	outfile = os.path.join( output, "src", "components", mod_name, "reducer_functions.ts" )
	fout = self.create_file( outfile, mod )

	fout.write ( TEMPL [ 'FUNCTIONS_START' ] % self.snippets )
	for ep in mod.endpoints.values():
		self._gen_reducer_function ( fout, ep, mod )


	fout.write ( TEMPL [ 'FUNCTIONS_END' ] % self.snippets )

	# close the output file
	fout.close()
	print( "Generated", outfile )

def _gen_reducer_function( self, fout, ep: Endpoint, mod: Module ):
	dct = {
		"action_name":  self.valid_function_name( ep.path ),
		"action_upper": self.valid_function_name ( ep.path ).upper(),
		"_expand_payload": '',
		"_snippet": ''
	}

	dct [ '_snippet' ] = self.snippets.get ( dct [ 'action_name' ], '' )
	s = dct['_snippet'].strip()
	if s == '':
		if dct['action_name'].endswith('_admin_add'):
			dct['_snippet'] = '\t// TODO: check this autogenerated code\n\tnew_state.admin.rows = [ ...new_state.admin.rows, %s ];' % ep.return_name
		elif dct['action_name'].endswith('_admin_update'):
			dct['_snippet'] = """
	// TODO: check this, it is autogenerated
	const rows = new_state.admin.rows.map( ( p: any ) => {
		if ( p.id !== %s.id ) return p;
		p = { ...p, ...%s};

		return p;
	} );
	new_state.admin.rows = rows;""" % (ep.return_name, ep.return_name)

		elif dct['action_name'].endswith('_admin_field'):
			dct['_snippet'] = '\tnew_state = post_admin_update( new_state, %s );' % ep.return_name
		elif dct['action_name'].endswith('_admin_del'):
			dct['_snippet'] = '\t// TODO: check this autogenerated code\n\tnew_state.admin.rows = new_state.admin.rows.filter( ( p ) => p.id != id );'
		elif dct['action_name'].endswith('_admin_list'):
			dct['_snippet'] = '\t// TODO: check this autogenerated code\n\tnew_state.admin.rows = [ ...%s ];' % ep.return_name

	# This code tries to get the return variables for explosion
	# By default, the params will be the variable name, used in both arrays and plain variables
	# But if the return_type is a structure (not array) then the structure fields are returned

	#print ( "EP: ", ep, dct )

	params = ''
	typ = ep.return_type
	if typ and typ != 1:
		if isinstance ( typ, str ):
			params = typ
		else:
			params = ', '.join(typ.plain_fields())

	mode = ''
	if ep.return_type.endswith('[]'):
		mode = 'no-expand'
		var_name = ep.return_name
		typ = ep.return_type
	elif typ:
		mode = 'expand'
		# dct [ '_expand_payload' ] = templates [ 'EXPAND_PAYLOAD' ] % { '_fields': params, '_name': ep.return_name }
		dct['_expand_payload'] = ''
		typ = ep.return_type
		var_name = ep.return_name  #'data'
	else:
		mode = 'no-expand'
		var_name = ep.return_name
		typ = ep.return_type

	dct['_var_name'] = var_name
	dct['type'] = type2typescript ( typ )
	if ep.is_array:
		dct['type'] += '[]'

	dct['module_name'] = mod.name

	fout.write(TEMPL['FUNCTION'] % dct)

